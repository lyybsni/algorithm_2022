#include <iostream>
#include <map>
#include <vector>
using namespace std;

int result[55] = {0};
int backtrace[55];

/**
 * @brief Solution 1.
 * 
 * As the graph is topologically sorted, the maximum length should be computed from the source to the sink.
 * Generally, the computation is generated by the path number, which is irrelavant to the number of vetices.
 * The complexity is O(|E|).
 */
void solve(int target, vector<map<int, int>> cost) {
    for(auto pair: cost[target]) {
        if (result[pair.first] + pair.second > result[target]) {
            result[target] = result[pair.first] + pair.second;
            backtrace[target] = pair.first;
        }
    }
}

string backtraceResult(int target) {
    string result = to_string(target);
    while(backtrace[target] != -2) {
        target = backtrace[target];
        result = to_string(target) + "->" + result;
    }
    return result;
}

int main() {

    for (int i = 0; i < 55; i++) {
        backtrace[i] = -1;      // set to an initial value
    }

    int source, sink;
    cin >> source >> sink;

    vector<map<int, int>> cost(sink + 1, map<int, int>());
    backtrace[source] = -2;

    int from, to, len;
    string path;
    while (cin >> path) {
        if (path == "0") {
            break;
        }

        int index_0 = path.find("->");
        int index_1 = path.find(":");

        from = stoi(path.substr(0, index_0));
        to = stoi(path.substr(index_0 + 2, index_1));
        len = stoi(path.substr(index_1 + 1));

        cost[to][from] = len;
    }

    for(int i = 0; i <= sink; i++) {
        solve(i, cost);
    }

    cout << result[sink] << endl << endl << backtraceResult(sink) << endl;

    return 0;
}